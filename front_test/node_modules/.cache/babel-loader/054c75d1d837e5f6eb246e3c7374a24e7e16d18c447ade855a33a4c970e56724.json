{"ast":null,"code":"import _objectSpread from\"C:/Users/kholoods/react/quizapp/front_test/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";// QuizPage.js\nimport React,{useState,useEffect,useCallback}from'react';import{useNavigate,useParams}from'react-router-dom';// Import useNavigate\nimport'./../../src/App.css';import{jsx as _jsx,jsxs as _jsxs}from\"react/jsx-runtime\";const QuizPage=()=>{const{id}=useParams();// Get quiz ID from URL parameter\nconst navigate=useNavigate();// Initialize navigate\nconst[quiz,setQuiz]=useState(null);const[currentQuestionIndex,setCurrentQuestionIndex]=useState(0);// Track the current question index\nconst[selectedAnswers,setSelectedAnswers]=useState({});// Track answers for all questions\nconst[timer,setTimer]=useState(30);// Timer for each question (30 seconds per question)\nconst[score,setScore]=useState(0);// Total score\n// Fetch quiz data on page load\nuseEffect(()=>{const fetchQuizData=async()=>{try{const response=await fetch(\"http://localhost:5000/api/quiz/\".concat(id));const data=await response.json();console.log('Quiz Data:',data);// Log the data to see what is returned\nsetQuiz(data);}catch(error){console.error('Error fetching quiz data:',error);}};fetchQuizData();},[id]);// Fetch quiz data on mount or when `id` changes\n// Log the selected answers and calculate score whenever selectedAnswers changes\nuseEffect(()=>{let totalScore=0;// Initialize total score to 0\nObject.entries(selectedAnswers).forEach(_ref=>{let[questionId,selectedAnswerText]=_ref;const question=quiz===null||quiz===void 0?void 0:quiz.questions.find(q=>q.id===parseInt(questionId));if(question){// Find the selected answer object by matching answer_text\nconst selectedAnswer=question.answer_options.find(answer=>answer.answer_text===selectedAnswerText);// Check if the selected answer is correct (is_correct: true)\nif(selectedAnswer!==null&&selectedAnswer!==void 0&&selectedAnswer.is_correct){totalScore+=question.marks;// Add marks for correct answer\n}}});setScore(totalScore);// Update the score\nconsole.log('Current Score:',totalScore);// Log current score to console\n},[selectedAnswers,quiz]);// Re-run when selectedAnswers or quiz changes\n// Memoize the handleNextQuestion function to prevent it from being recreated on every render\nconst handleNextQuestion=useCallback(()=>{var _quiz$questions$curre;if(selectedAnswers[quiz===null||quiz===void 0?void 0:(_quiz$questions$curre=quiz.questions[currentQuestionIndex])===null||_quiz$questions$curre===void 0?void 0:_quiz$questions$curre.id]){setCurrentQuestionIndex(prevIndex=>prevIndex+1);// Move to next question\nsetTimer(30);// Reset timer for the next question\n}},[selectedAnswers,currentQuestionIndex,quiz]);// Countdown timer for each question\nuseEffect(()=>{if(timer>0&&currentQuestionIndex<(quiz===null||quiz===void 0?void 0:quiz.questions.length)){const timerInterval=setInterval(()=>{setTimer(prevTimer=>prevTimer-1);},1000);return()=>clearInterval(timerInterval);}else if(timer===0){handleNextQuestion();// Move to next question when timer expires\n}},[timer,currentQuestionIndex,quiz,handleNextQuestion]);// Submit quiz and redirect to the QuizResultPage with the score\nconst submitQuiz=async()=>{if(currentQuestionIndex!==(quiz===null||quiz===void 0?void 0:quiz.questions.length)){//alert('Please complete the quiz before submitting.');\nreturn;}try{const response=await fetch('http://localhost:5000/api/submit-quiz',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({quizId:id,answers:getAnswers()})});const data=await response.json();console.log(data.message);// After submitting, redirect to results page and pass the score in state\nnavigate(\"/quiz-results/\".concat(id),{state:{score}});}catch(error){console.error('Error submitting quiz:',error);}};// Get answers in the required format to send to the backend (assuming { questionId, answerId })\nconst getAnswers=()=>{return quiz===null||quiz===void 0?void 0:quiz.questions.map(question=>({questionId:question.id,answerId:selectedAnswers[question.id]}));};if(!quiz){return/*#__PURE__*/_jsx(\"div\",{children:\"Loading quiz...\"});}if(!(quiz!==null&&quiz!==void 0&&quiz.questions)||quiz.questions.length===0){return/*#__PURE__*/_jsx(\"div\",{children:\"No questions available for this quiz.\"});}const currentQuestion=quiz===null||quiz===void 0?void 0:quiz.questions[currentQuestionIndex];return/*#__PURE__*/_jsxs(\"div\",{children:[/*#__PURE__*/_jsx(\"h1\",{children:quiz.quiz_title}),/*#__PURE__*/_jsxs(\"div\",{children:[/*#__PURE__*/_jsx(\"h3\",{children:currentQuestion===null||currentQuestion===void 0?void 0:currentQuestion.question_text}),/*#__PURE__*/_jsxs(\"div\",{children:[\"Time Left: \",timer,\"s\"]}),/*#__PURE__*/_jsx(\"div\",{className:\"answers\",children:currentQuestion===null||currentQuestion===void 0?void 0:currentQuestion.answer_options.map(answer=>/*#__PURE__*/_jsx(\"div\",{// Use answer_text as key since it's unique\nclassName:\"answer-option \".concat(selectedAnswers[currentQuestion.id]===answer.answer_text?'selected':'')// Apply 'selected' class based on text match\n,onClick:()=>{setSelectedAnswers(prevAnswers=>_objectSpread(_objectSpread({},prevAnswers),{},{[currentQuestion.id]:answer.answer_text// Store answer by question ID\n}));},children:answer.answer_text},answer.answer_text))})]}),/*#__PURE__*/_jsx(\"div\",{children:currentQuestionIndex<quiz.questions.length-1?/*#__PURE__*/_jsx(\"button\",{className:\"next-question-btn\",onClick:handleNextQuestion,disabled:!selectedAnswers[currentQuestion.id],children:\"Next Question\"}):/*#__PURE__*/_jsx(\"button\",{className:\"submit-quiz-btn\",onClick:submitQuiz,children:\"Submit Quiz\"})})]});};export default QuizPage;","map":{"version":3,"names":["React","useState","useEffect","useCallback","useNavigate","useParams","jsx","_jsx","jsxs","_jsxs","QuizPage","id","navigate","quiz","setQuiz","currentQuestionIndex","setCurrentQuestionIndex","selectedAnswers","setSelectedAnswers","timer","setTimer","score","setScore","fetchQuizData","response","fetch","concat","data","json","console","log","error","totalScore","Object","entries","forEach","_ref","questionId","selectedAnswerText","question","questions","find","q","parseInt","selectedAnswer","answer_options","answer","answer_text","is_correct","marks","handleNextQuestion","_quiz$questions$curre","prevIndex","length","timerInterval","setInterval","prevTimer","clearInterval","submitQuiz","method","headers","body","JSON","stringify","quizId","answers","getAnswers","message","state","map","answerId","children","currentQuestion","quiz_title","question_text","className","onClick","prevAnswers","_objectSpread","disabled"],"sources":["C:/Users/kholoods/react/quizapp/front_test/src/pages/QuizPage.js"],"sourcesContent":["// QuizPage.js\r\nimport React, { useState, useEffect, useCallback } from 'react';\r\nimport { useNavigate, useParams } from 'react-router-dom'; // Import useNavigate\r\nimport './../../src/App.css';\r\n\r\nconst QuizPage = () => {\r\n  const { id } = useParams(); // Get quiz ID from URL parameter\r\n  const navigate = useNavigate(); // Initialize navigate\r\n  const [quiz, setQuiz] = useState(null);\r\n  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0); // Track the current question index\r\n  const [selectedAnswers, setSelectedAnswers] = useState({}); // Track answers for all questions\r\n  const [timer, setTimer] = useState(30); // Timer for each question (30 seconds per question)\r\n  const [score, setScore] = useState(0); // Total score\r\n\r\n  // Fetch quiz data on page load\r\n  useEffect(() => {\r\n    const fetchQuizData = async () => {\r\n      try {\r\n        const response = await fetch(`http://localhost:5000/api/quiz/${id}`);\r\n        const data = await response.json();\r\n        console.log('Quiz Data:', data); // Log the data to see what is returned\r\n        setQuiz(data);\r\n      } catch (error) {\r\n        console.error('Error fetching quiz data:', error);\r\n      }\r\n    };\r\n\r\n    fetchQuizData();\r\n  }, [id]); // Fetch quiz data on mount or when `id` changes\r\n\r\n  // Log the selected answers and calculate score whenever selectedAnswers changes\r\n  useEffect(() => {\r\n    let totalScore = 0; // Initialize total score to 0\r\n    Object.entries(selectedAnswers).forEach(([questionId, selectedAnswerText]) => {\r\n      const question = quiz?.questions.find((q) => q.id === parseInt(questionId));\r\n      if (question) {\r\n        // Find the selected answer object by matching answer_text\r\n        const selectedAnswer = question.answer_options.find(\r\n          (answer) => answer.answer_text === selectedAnswerText\r\n        );\r\n        \r\n        // Check if the selected answer is correct (is_correct: true)\r\n        if (selectedAnswer?.is_correct) {\r\n          totalScore += question.marks; // Add marks for correct answer\r\n        }\r\n      }\r\n    });\r\n\r\n    setScore(totalScore); // Update the score\r\n    console.log('Current Score:', totalScore); // Log current score to console\r\n  }, [selectedAnswers, quiz]); // Re-run when selectedAnswers or quiz changes\r\n\r\n  // Memoize the handleNextQuestion function to prevent it from being recreated on every render\r\n  const handleNextQuestion = useCallback(() => {\r\n    if (selectedAnswers[quiz?.questions[currentQuestionIndex]?.id]) {\r\n      setCurrentQuestionIndex((prevIndex) => prevIndex + 1); // Move to next question\r\n      setTimer(30); // Reset timer for the next question\r\n    }\r\n  }, [selectedAnswers, currentQuestionIndex, quiz]);\r\n\r\n  // Countdown timer for each question\r\n  useEffect(() => {\r\n    if (timer > 0 && currentQuestionIndex < quiz?.questions.length) {\r\n      const timerInterval = setInterval(() => {\r\n        setTimer((prevTimer) => prevTimer - 1);\r\n      }, 1000);\r\n      return () => clearInterval(timerInterval);\r\n    } else if (timer === 0) {\r\n      handleNextQuestion(); // Move to next question when timer expires\r\n    }\r\n  }, [timer, currentQuestionIndex, quiz, handleNextQuestion]);\r\n\r\n  // Submit quiz and redirect to the QuizResultPage with the score\r\n  const submitQuiz = async () => {\r\n    if (currentQuestionIndex !== quiz?.questions.length) {\r\n      //alert('Please complete the quiz before submitting.');\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const response = await fetch('http://localhost:5000/api/submit-quiz', {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        body: JSON.stringify({ quizId: id, answers: getAnswers() }),\r\n      });\r\n      const data = await response.json();\r\n      console.log(data.message);\r\n\r\n      // After submitting, redirect to results page and pass the score in state\r\n      navigate(`/quiz-results/${id}`, { state: { score } });\r\n    } catch (error) {\r\n      console.error('Error submitting quiz:', error);\r\n    }\r\n  };\r\n\r\n\r\n  // Get answers in the required format to send to the backend (assuming { questionId, answerId })\r\n  const getAnswers = () => {\r\n    return quiz?.questions.map((question) => ({\r\n      questionId: question.id,\r\n      answerId: selectedAnswers[question.id],\r\n    }));\r\n  };\r\n\r\n  if (!quiz) {\r\n    return <div>Loading quiz...</div>;\r\n  }\r\n\r\n  if (!quiz?.questions || quiz.questions.length === 0) {\r\n    return <div>No questions available for this quiz.</div>;\r\n  }\r\n\r\n  const currentQuestion = quiz?.questions[currentQuestionIndex];\r\n\r\n  return (\r\n    <div>\r\n      <h1>{quiz.quiz_title}</h1>\r\n\r\n      {/* Display Question and Timer */}\r\n      <div>\r\n        <h3>{currentQuestion?.question_text}</h3>\r\n        <div>Time Left: {timer}s</div>\r\n\r\n        {/* Display the answer options */}\r\n        <div className=\"answers\">\r\n          {currentQuestion?.answer_options.map((answer) => (\r\n            <div\r\n              key={answer.answer_text} // Use answer_text as key since it's unique\r\n              className={`answer-option ${selectedAnswers[currentQuestion.id] === answer.answer_text ? 'selected' : ''}`} // Apply 'selected' class based on text match\r\n              onClick={() => {\r\n                setSelectedAnswers((prevAnswers) => ({\r\n                  ...prevAnswers,\r\n                  [currentQuestion.id]: answer.answer_text, // Store answer by question ID\r\n                }));\r\n              }}\r\n            >\r\n              {answer.answer_text}\r\n            </div>\r\n          ))}\r\n        </div>\r\n      </div>\r\n\r\n      {/* Next Button */}\r\n      <div>\r\n        {currentQuestionIndex < quiz.questions.length - 1 ? (\r\n          <button \r\n          className=\"next-question-btn\"\r\n          onClick={handleNextQuestion} disabled={!selectedAnswers[currentQuestion.id]}>\r\n            Next Question\r\n          </button>\r\n        ) : (\r\n          <button className=\"submit-quiz-btn\" onClick={submitQuiz}>Submit Quiz</button>\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default QuizPage;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}